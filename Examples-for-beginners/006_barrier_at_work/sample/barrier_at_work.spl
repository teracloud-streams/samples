/*
 * This example shows how to synchronize the incoming tuples using a 
 * Barrier operator. It uses a bank deposit/debit scenario to 
 * split the deposit/debit requests, perform that account activity,
 * and then combine the post-activity results with the incoming requests.
 * Barrier operator provides what is needed to accomplish that. 
 */
namespace sample;

composite barrier_at_work
{
	type
		BankTxSchema = uint32 accountNumber, rstring txType, float64 currentBalance, float64 txAmount;
		DepositInputSchema = uint32 accountNumber, float64 currentBalance, float64 depositAmount;
		DebitInputSchema = uint32 accountNumber, float64 currentBalance, float64 debitAmount;
		TxResultSchema = float64 newBalance;
		PostTxResultSchema = uint32 accountNumber, float64 currentBalance;
		
	graph
		// Read the bank transaction details one at a time.
		stream<BankTxSchema> TxData = FileSource()
		{
			param
				file: getApplicationDir() + "/data/bank_tasks.dat";
				format: csv;
		}

		// Apply filter to pick the deposit requests.
		stream<DepositInputSchema> DepositRequest = Functor(TxData)
		{
			param
				filter: txType == "Deposit";
			output
				DepositRequest: depositAmount = txAmount;
		}

		// Apply filter to pick the debit requests.
		stream<DebitInputSchema> DebitRequest = Functor(TxData)
		{
			param
				filter: txType == "Debit";
			output
				DebitRequest: debitAmount = txAmount;
		}

		// Compute the new balance because of the deposit activity.
		stream<TxResultSchema> DepositResult = Functor(DepositRequest)
		{
			output
				DepositResult: newBalance = currentBalance + depositAmount;
		}

		// Compute the new balance because of the debit activity.
		stream<TxResultSchema> DebitResult = Functor(DebitRequest)
		{
			output
				DebitResult: newBalance = currentBalance - debitAmount;
		}

		// Use a barrier to synchronize the deposit request and result.
		stream<PostTxResultSchema> FinalDepositResult = Barrier(DepositRequest; DepositResult)
		{
			output
				FinalDepositResult: accountNumber = DepositRequest.accountNumber,
					currentBalance = DepositResult.newBalance;
		}

		// Use a barrier to synchronize the debit request and result.
		stream<PostTxResultSchema> FinalDebitResult = Barrier(DebitRequest; DebitResult)
		{
			output
				FinalDebitResult: accountNumber = DebitRequest.accountNumber, currentBalance = DebitResult.newBalance;
		}

		// Write the deposit results to a sink file.
		() as FileWriter1 = FileSink(FinalDepositResult)
		{
			param
				file: "/tmp/006_barrier_bank_tasks_deposit.result";
		}

		// Write the debit results to a sink file.
		() as FileWriter2 = FileSink(FinalDebitResult)
		{
			param
				file: "/tmp/006_barrier_bank_tasks_debit.result";
		}

		() as DebitPrinter = Custom(FinalDebitResult as in0)
		{
			logic
				onTuple in0:
				{
					println(in0);
				}
			config
				placement: partitionExlocation("debit");
		}
		
		() as Printer = Custom(FinalDepositResult as in0)
		{
			logic
				onTuple in0:
				{
					println(in0);
				}
			config
				placement: partitionExlocation("debit");
		}
}
